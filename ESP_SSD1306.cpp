/*********************************************************************

    Modified Adafruit Library to work with OLED SSD1306_128_64
    with SPI communication only *

    //commented for ESP8266 compatibility    indicates the files commented
                        with respect to the default Adafruit library

    //Added for compatibility with ESP8266 board   indicates where has been
 						added code with respect to default Adafruit library

 	Appart from that all the classes name Adafruit_SSD1306 have been replaced
 	for ESP_SSD1306, and has been included the header "ESP_SSD1306.h"



    By: Jordi Segura

  This is a library for Monochrome OLEDs based on SSD1306 drivers

  Pick one up today in the adafruit shop!
  ------> http://www.adafruit.com/category/63_98

  These displays use SPI to communicate, 4 or 5 pins are required to
  interface

  Adafruit invests time and resources providing this open source code,
  please support Adafruit and open-source hardware by purchasing
  products from Adafruit!

  Written by Limor Fried/Ladyada  for Adafruit Industries.
  BSD license, check license.txt for more information
  All text above, and the splash screen below must be included in any redistribution
*********************************************************************/



//#include <avr/pgmspace.h>		//commented for ESP8266 compatibility
#ifndef __SAM3X8E__
// #include <util/delay.h>		//commented for ESP8266 compatibility
#endif
#include <stdlib.h>

#include <Wire.h>				//needed for I2C comm

#include "OWMAdafruit_GFX.h"
#include "ESP_SSD1306.h"		//Instead of "Adafruit_SSD1306.h"

// the memory buffer for the LCD


static uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x08, 0x3E, 0x7E, 0x63, 0x63, 0x63, 0xE3, 0xC2, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xF8,
  0xF8, 0x10, 0x10, 0x18, 0xF8, 0xF0, 0xF0, 0x10, 0x18, 0x18, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x80,
  0x98, 0xD8, 0xD8, 0xD8, 0xD8, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0x20, 0x10, 0x18,
  0x18, 0x00, 0x18, 0xFE, 0xFE, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x04, 0x0C, 0x0C, 0x0C, 0x0C, 0x0E, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x0F,
  0x0F, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
  0x07, 0x0C, 0x0C, 0x04, 0x06, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x07, 0x0F, 0x0C, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x80, 0xE0, 0xF0, 0x30, 0x18, 0x18, 0x18, 0x18, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,
  0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x80, 0xC0,
  0xC0, 0x00, 0x00, 0x80, 0xC0, 0xC0, 0xC0, 0x80, 0x80, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x80, 0x80,
  0xC0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0x80, 0x80, 0xC0, 0xC0, 0x80,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x07, 0x1F, 0x3F, 0x30, 0x60, 0x60, 0x60, 0x66, 0x3E, 0x3E, 0x3E, 0x00, 0x00, 0x3C,
  0x3C, 0x66, 0x66, 0x26, 0x36, 0x7F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x7F, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x1F, 0x3F, 0x71, 0x60, 0x60, 0x20, 0x3B, 0x7F, 0x7F, 0x00, 0x00, 0x1F, 0x3F, 0x37,
  0x66, 0x66, 0x66, 0x27, 0x27, 0x06, 0x00, 0x00, 0x00, 0x7F, 0x7F, 0x01, 0x00, 0x00, 0x01, 0x7F,
  0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

};

/*
  static uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {
  // size is 128 x 64
  0xE4, 0x9B, 0xA6, 0xD5, 0xA8, 0x66, 0xD5, 0xEA, 0xB9, 0xC2, 0xD9, 0xB6, 0xE5, 0xFA, 0x66, 0xFD,
  0xDA, 0xF5, 0xDC, 0xFB, 0xDD, 0xFA, 0xF7, 0xF5, 0xF7, 0xFE, 0xF5, 0xEF, 0xED, 0xFF, 0xFD, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFD, 0xFB, 0xFD, 0xFC, 0xFF, 0xFB, 0xFC, 0xF5, 0xFE,
  0xBB, 0x79, 0xDF, 0x74, 0xFB, 0x9D, 0xF5, 0xAE, 0xB5, 0xDF, 0xAA, 0xF6, 0x3B, 0xE9, 0xED, 0x36,
  0xDB, 0x6E, 0x63, 0xDE, 0x5E, 0xE3, 0x9E, 0x69, 0x95, 0x5A, 0x65, 0x3A, 0x99, 0x65, 0x5A, 0xA5,
  0x00, 0x01, 0x02, 0x01, 0x00, 0x01, 0x00, 0x01, 0x02, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01,
  0x00, 0x02, 0x00, 0x00, 0x01, 0x02, 0x02, 0x01, 0x00, 0x00, 0x01, 0x02, 0x00, 0x03, 0x00, 0x00,
  0x01, 0x02, 0x02, 0x09, 0x20, 0x0B, 0x62, 0x04, 0x03, 0x98, 0x95, 0x02, 0x61, 0x05, 0x00, 0x65,
  0xF6, 0xFF, 0xFF, 0xEB, 0xF7, 0xFF, 0xFE, 0xEF, 0xFF, 0xFB, 0xFB, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF,
  0xFF, 0xF7, 0xFE, 0xEF, 0xFF, 0xF7, 0x7F, 0xFF, 0xFD, 0xBF, 0x1E, 0x0F, 0x1F, 0xFF, 0xFF, 0x9F,
  0x0F, 0x8F, 0xAF, 0xFF, 0xBF, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0x7F, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0xEE, 0xB9, 0x75, 0xD7, 0x6D, 0xDA, 0xD9, 0xA6, 0xFD, 0x4B,
  0x6E, 0x99, 0xE7, 0x1A, 0x55, 0xAA, 0x55, 0x2A, 0xDE, 0xBD, 0xFE, 0xFE, 0xFD, 0xFD, 0xFC, 0xFD,
  0xFC, 0x0E, 0x0C, 0xC4, 0xCC, 0x0C, 0x1E, 0xFE, 0xFC, 0xFC, 0x3C, 0x0E, 0xCC, 0xEC, 0x84, 0x8C,
  0xFC, 0xFC, 0xFC, 0xFC, 0x1C, 0x0E, 0xE4, 0xC4, 0x0C, 0x1C, 0xFC, 0xFC, 0xFC, 0xFE, 0x7C, 0x0C,
  0x0C, 0xDC, 0xFE, 0xFE, 0xFC, 0xFD, 0xFD, 0xFE, 0x3C, 0x9E, 0x05, 0xA4, 0x00, 0x94, 0x05, 0x40,
  0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xBF, 0xBF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x3F,
  0x67, 0xC3, 0xC7, 0xEF, 0xFF, 0xFC, 0xF8, 0xFC, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFE, 0xFF, 0xF9, 0xF9,
  0xE1, 0xF3, 0x9F, 0x0F, 0x8F, 0x9F, 0xFF, 0xFF, 0xFD, 0xD5, 0xCF, 0x72, 0xBB, 0xC6, 0x56, 0x6B,
  0xD3, 0x69, 0x96, 0xC5, 0x52, 0xA5, 0x54, 0xA9, 0xA6, 0xC9, 0xD0, 0xE6, 0xF3, 0xFB, 0xFF, 0xFF,
  0xFF, 0x00, 0x00, 0xF1, 0xF1, 0x00, 0x0C, 0xBF, 0xFF, 0xFF, 0x11, 0x00, 0xFE, 0xFF, 0x7F, 0x1F,
  0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1F, 0x87, 0xC0, 0xF8, 0xFF, 0xFF, 0xFF, 0x8F, 0x01, 0x80, 0x10,
  0x00, 0x0D, 0xFF, 0xFF, 0xFF, 0xFB, 0xE1, 0xE1, 0xA0, 0x01, 0x81, 0x20, 0x01, 0x60, 0x40, 0x08,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFD, 0xFF, 0xFE, 0xFE, 0xFF, 0x8F, 0x8E, 0xCC, 0xFC,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0x71, 0x11, 0x31, 0x1F, 0xBF, 0xFF, 0xFF, 0xFB, 0x9B, 0xFD, 0xD7,
  0xAD, 0xBB, 0xE6, 0xB9, 0xB6, 0xAB, 0xE6, 0x76, 0xBF, 0xAF, 0xDF, 0x0F, 0x07, 0x1F, 0x1F, 0x2F,
  0x0F, 0x16, 0x08, 0x04, 0x0C, 0xBC, 0x6E, 0xD7, 0x0F, 0x0F, 0x0F, 0x0E, 0x84, 0x0C, 0x0C, 0x0C,
  0x0F, 0x0F, 0x0F, 0x0F, 0x0C, 0x04, 0x08, 0x24, 0x04, 0x0F, 0x0F, 0x07, 0x0F, 0x0F, 0x0F, 0x0D,
  0x0C, 0x07, 0x0F, 0x07, 0x0F, 0x0F, 0x07, 0x87, 0x0F, 0x2E, 0x84, 0x14, 0x89, 0xA8, 0x40, 0x96,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x79, 0x10, 0x18, 0x1A, 0x3F,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x0F, 0x0F,
  0x0F, 0x0F, 0x07, 0x0F, 0x07, 0x03, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x6F, 0x47, 0xE0, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xDB, 0x7D, 0xAF, 0xF3, 0x9D, 0xFB, 0xA5, 0x6D, 0xEE, 0x6B, 0xC0, 0x80, 0xA0, 0xC0, 0x40, 0xC8,
  0xC0, 0x80, 0x00, 0xC0, 0xC0, 0x3B, 0x9D, 0x41, 0xC0, 0x80, 0x00, 0x80, 0x00, 0xC0, 0x40, 0x00,
  0x00, 0x40, 0x80, 0x00, 0x40, 0x80, 0x00, 0x00, 0x80, 0x00, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x40, 0x40, 0x00, 0x10, 0x10, 0x45, 0x48, 0x2A, 0x00, 0x95,
  0x75, 0x6F, 0xBD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xF3,
  0xE1, 0xF1, 0x3F, 0x1F, 0x1F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF0,
  0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFC, 0xFC, 0xFF, 0xFF, 0xBF, 0xFF, 0x7F, 0x3F, 0x3F, 0x7F,
  0xFF, 0xE7, 0xC7, 0xC3, 0xF8, 0xFC, 0xFC, 0xFE, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x3F, 0xFF, 0xFF,
  0x5F, 0xFF, 0xEF, 0x3A, 0xEB, 0xED, 0x33, 0xED, 0xD9, 0x27, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0xA0,
  0x00, 0x00, 0x20, 0x00, 0x40, 0x20, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x01, 0x20, 0x80, 0x00, 0x99, 0x00,
  0xDD, 0x67, 0x95, 0x5F, 0xD7, 0xAE, 0x77, 0x9F, 0x7F, 0xDF, 0x5F, 0xBF, 0xFF, 0x7F, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xF8, 0xF8, 0xFC, 0xFF, 0xF7, 0xF1, 0xF1, 0xF1,
  0xFF, 0xFF, 0xF3, 0xF1, 0xE3, 0xFF, 0xFF, 0xFF, 0xF0, 0x70, 0xF9, 0x7E, 0xDF, 0xFC, 0xBE, 0xFE,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFE, 0xFF, 0xFF,
  0xFF, 0xF7, 0xFF, 0xEA, 0xBF, 0xE2, 0x9B, 0x6D, 0xDB, 0x46, 0x01, 0x06, 0x02, 0x04, 0x05, 0x02,
  0x00, 0x03, 0x00, 0x02, 0x02, 0x05, 0x0A, 0x00, 0x06, 0x00, 0x04, 0x02, 0x02, 0x04, 0x02, 0x00,
  0x02, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x00, 0x00, 0x21,
  0xAE, 0x16, 0x5F, 0xB9, 0xA9, 0x1E, 0x57, 0xB5, 0x56, 0xA6, 0x7F, 0x49, 0x5E, 0x63, 0x9F, 0x59,
  0x5B, 0xAF, 0x5F, 0xBF, 0xBF, 0x9F, 0x6F, 0xBF, 0xBF, 0x5F, 0x7F, 0xDF, 0xBF, 0xAF, 0x77, 0xDF,
  0xDF, 0x67, 0x9F, 0x7F, 0x6B, 0x5F, 0x56, 0x6E, 0x5B, 0x6F, 0x77, 0x4A, 0x59, 0xAF, 0x65, 0x5B,
  0x57, 0x67, 0xBE, 0x4B, 0xBF, 0x5B, 0x9B, 0x7F, 0x5F, 0xBB, 0xEF, 0x7E, 0x7F, 0x9F, 0x5F, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFB, 0x15, 0xE9, 0x5A, 0x15, 0xA2, 0x19, 0x19, 0x22, 0x91, 0x15, 0x02, 0xA8,
  0x11, 0x2C, 0xA2, 0x09, 0x02, 0x58, 0x18, 0x42, 0x14, 0x41, 0x58, 0x01, 0x00, 0x55, 0x00, 0x52,
  0x00, 0x10, 0x08, 0x92, 0x0A, 0x20, 0x40, 0x0A, 0x01, 0x28, 0x20, 0x00, 0x04, 0x10, 0x00, 0x08,
  0x04, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0x00, 0x08,
  };


*/


// the most basic function, set a single pixel
void ESP_SSD1306::drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
    return;

  // check rotation, move pixel around if necessary
  switch (getRotation()) {
    case 1:
      adagfxswap(x, y);
      x = WIDTH - x - 1;
      break;
    case 2:
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
      break;
    case 3:
      adagfxswap(x, y);
      y = HEIGHT - y - 1;
      break;
  }

  // x is which column
  switch (color)
  {
    case WHITE:   buffer[x + (y / 8)*SSD1306_LCDWIDTH] |=  (1 << (y & 7)); break;
    case BLACK:   buffer[x + (y / 8)*SSD1306_LCDWIDTH] &= ~(1 << (y & 7)); break;
    case INVERSE: buffer[x + (y / 8)*SSD1306_LCDWIDTH] ^=  (1 << (y & 7)); break;
  }

}

ESP_SSD1306::ESP_SSD1306(int8_t SID, int8_t SCLK, int8_t DC, int8_t RST, int8_t CS) : Adafruit_GFX(SSD1306_LCDWIDTH, SSD1306_LCDHEIGHT) {
  cs = CS;
  rst = RST;
  dc = DC;
  sclk = SCLK;
  sid = SID;
  hwSPI = false;
}

// constructor for hardware SPI - we indicate DataCommand, ChipSelect, Reset
ESP_SSD1306::ESP_SSD1306(int8_t DC, int8_t RST, int8_t CS) : Adafruit_GFX(SSD1306_LCDWIDTH, SSD1306_LCDHEIGHT) {
  dc = DC;
  rst = RST;
  cs = CS;
  hwSPI = true;
}

// initializer for I2C - we only indicate the reset pin!
ESP_SSD1306::ESP_SSD1306(int8_t reset) :
  Adafruit_GFX(SSD1306_LCDWIDTH, SSD1306_LCDHEIGHT) {
  sclk = dc = cs = sid = -1;
  rst = reset;
}


void ESP_SSD1306::begin(uint8_t vccstate, uint8_t i2caddr, bool reset) {
  _vccstate = vccstate;
  _i2caddr = i2caddr;

  // set pin directions
  if (sid != -1) {
    pinMode(dc, OUTPUT);
    pinMode(cs, OUTPUT);
    //commented for ESP8266 compatibility
    //    csport      = portOutputRegister(digitalPinToPort(cs));
    //    cspinmask   = digitalPinToBitMask(cs);
    //    dcport      = portOutputRegister(digitalPinToPort(dc));
    //    dcpinmask   = digitalPinToBitMask(dc);
    if (!hwSPI) {
      // set pins for software-SPI
      pinMode(sid, OUTPUT);
      pinMode(sclk, OUTPUT);
      //commented for ESP8266 compatibility
      //      clkport     = portOutputRegister(digitalPinToPort(sclk));
      //      clkpinmask  = digitalPinToBitMask(sclk);
      //      mosiport    = portOutputRegister(digitalPinToPort(sid));
      //      mosipinmask = digitalPinToBitMask(sid);
    }
    if (hwSPI) {
      //      SPI.begin ();
#ifdef __SAM3X8E__
      //      SPI.setClockDivider (9); 				// 9.3 MHz
#elif defined ESP8266    					//Added for compatibility with ESP8266 board
      //	  SPI.setClockDivider (SPI_CLOCK_DIV2); // 26/2 = 13 MHz (freq ESP8266 26 MHz)
#else
      //      SPI.setClockDivider (SPI_CLOCK_DIV2); // 8 MHz
#endif
      //		SPI.setDataMode(SPI_MODE0);		//optional
      //	  	SPI.setBitOrder(MSBFIRST);		//optional
    }
  }
  else
  {
    // I2C Init
    Wire.begin();
#ifdef __SAM3X8E__
    // Force 400 KHz I2C, rawr! (Uses pins 20, 21 for SDA, SCL)
    TWI1->TWI_CWGR = 0;
    TWI1->TWI_CWGR = ((VARIANT_MCK / (2 * 400000)) - 4) * 0x101;
#endif
  }

  if (reset) {
    // Setup reset pin direction (used by both SPI and I2C)
    pinMode(rst, OUTPUT);
    digitalWrite(rst, HIGH);
    // VDD (3.3V) goes high at start, lets just chill for a ms
    vTaskDelay(1 / portTICK_PERIOD_MS);

    // bring reset low
    digitalWrite(rst, LOW);
    // wait 10ms
    vTaskDelay(10 / portTICK_PERIOD_MS);
    // bring out of reset
    digitalWrite(rst, HIGH);
    // turn on VCC (9V?)
  }

#if defined SSD1306_128_32
  // Init sequence for 128x32 OLED module
  ssd1306_command(SSD1306_DISPLAYOFF);                    // 0xAE
  ssd1306_command(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
  ssd1306_command(0x80);                                  // the suggested ratio 0x80
  ssd1306_command(SSD1306_SETMULTIPLEX);                  // 0xA8
  ssd1306_command(0x1F);
  ssd1306_command(SSD1306_SETDISPLAYOFFSET);              // 0xD3
  ssd1306_command(0x0);                                   // no offset
  ssd1306_command(SSD1306_SETSTARTLINE | 0x0);            // line #0
  ssd1306_command(SSD1306_CHARGEPUMP);                    // 0x8D
  if (vccstate == SSD1306_EXTERNALVCC)
  {
    ssd1306_command(0x10);
  }
  else
  {
    ssd1306_command(0x14);
  }
  ssd1306_command(SSD1306_MEMORYMODE);                    // 0x20
  ssd1306_command(0x00);                                  // 0x0 act like ks0108
  ssd1306_command(SSD1306_SEGREMAP | 0x1);
  ssd1306_command(SSD1306_COMSCANDEC);
  ssd1306_command(SSD1306_SETCOMPINS);                    // 0xDA
  ssd1306_command(0x02);
  ssd1306_command(SSD1306_SETCONTRAST);                   // 0x81
  ssd1306_command(0x8F);
  ssd1306_command(SSD1306_SETPRECHARGE);                  // 0xd9
  if (vccstate == SSD1306_EXTERNALVCC)
  {
    ssd1306_command(0x22);
  }
  else
  {
    ssd1306_command(0xF1);
  }
  ssd1306_command(SSD1306_SETVCOMDETECT);                 // 0xDB
  ssd1306_command(0x40);
  ssd1306_command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
  ssd1306_command(SSD1306_NORMALDISPLAY);                 // 0xA6
#endif

#if defined SSD1306_128_64
  // Init sequence for 128x64 OLED module
  ssd1306_command(SSD1306_DISPLAYOFF);                    // 0xAE
  ssd1306_command(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
  ssd1306_command(0x80);                                  // the suggested ratio 0x80
  ssd1306_command(SSD1306_SETMULTIPLEX);                  // 0xA8
  ssd1306_command(0x3F);
  ssd1306_command(SSD1306_SETDISPLAYOFFSET);              // 0xD3
  ssd1306_command(0x0);                                   // no offset
  ssd1306_command(SSD1306_SETSTARTLINE | 0x0);            // line #0
  ssd1306_command(SSD1306_CHARGEPUMP);                    // 0x8D
  if (vccstate == SSD1306_EXTERNALVCC)
  {
    ssd1306_command(0x10);
  }
  else
  {
    ssd1306_command(0x14);
  }
  ssd1306_command(SSD1306_MEMORYMODE);                    // 0x20
  ssd1306_command(0x00);                                  // 0x0 act like ks0108
  ssd1306_command(SSD1306_SEGREMAP | 0x1);
  ssd1306_command(SSD1306_COMSCANDEC);
  ssd1306_command(SSD1306_SETCOMPINS);                    // 0xDA
  ssd1306_command(0x12);
  ssd1306_command(SSD1306_SETCONTRAST);                   // 0x81
  if (vccstate == SSD1306_EXTERNALVCC)
  {
    ssd1306_command(0x9F);
  }
  else
  {
    ssd1306_command(0xCF);
  }
  ssd1306_command(SSD1306_SETPRECHARGE);                  // 0xd9
  if (vccstate == SSD1306_EXTERNALVCC)
  {
    ssd1306_command(0x22);
  }
  else
  {
    ssd1306_command(0xF1);
  }
  ssd1306_command(SSD1306_SETVCOMDETECT);                 // 0xDB
  ssd1306_command(0x40);
  ssd1306_command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
  ssd1306_command(SSD1306_NORMALDISPLAY);                 // 0xA6
#endif

#if defined SSD1306_96_16
  // Init sequence for 96x16 OLED module
  ssd1306_command(SSD1306_DISPLAYOFF);                    // 0xAE
  ssd1306_command(SSD1306_SETDISPLAYCLOCKDIV);            // 0xD5
  ssd1306_command(0x80);                                  // the suggested ratio 0x80
  ssd1306_command(SSD1306_SETMULTIPLEX);                  // 0xA8
  ssd1306_command(0x0F);
  ssd1306_command(SSD1306_SETDISPLAYOFFSET);              // 0xD3
  ssd1306_command(0x00);                                   // no offset
  ssd1306_command(SSD1306_SETSTARTLINE | 0x0);            // line #0
  ssd1306_command(SSD1306_CHARGEPUMP);                    // 0x8D
  if (vccstate == SSD1306_EXTERNALVCC)
  {
    ssd1306_command(0x10);
  }
  else
  {
    ssd1306_command(0x14);
  }
  ssd1306_command(SSD1306_MEMORYMODE);                    // 0x20
  ssd1306_command(0x00);                                  // 0x0 act like ks0108
  ssd1306_command(SSD1306_SEGREMAP | 0x1);
  ssd1306_command(SSD1306_COMSCANDEC);
  ssd1306_command(SSD1306_SETCOMPINS);                    // 0xDA
  ssd1306_command(0x2);	//ada x12
  ssd1306_command(SSD1306_SETCONTRAST);                   // 0x81
  if (vccstate == SSD1306_EXTERNALVCC)
  {
    ssd1306_command(0x10);
  }
  else
  {
    ssd1306_command(0xAF);
  }
  ssd1306_command(SSD1306_SETPRECHARGE);                  // 0xd9
  if (vccstate == SSD1306_EXTERNALVCC)
  {
    ssd1306_command(0x22);
  }
  else
  {
    ssd1306_command(0xF1);
  }
  ssd1306_command(SSD1306_SETVCOMDETECT);                 // 0xDB
  ssd1306_command(0x40);
  ssd1306_command(SSD1306_DISPLAYALLON_RESUME);           // 0xA4
  ssd1306_command(SSD1306_NORMALDISPLAY);                 // 0xA6
#endif

  ssd1306_command(SSD1306_DISPLAYON);//--turn on oled panel
}


void ESP_SSD1306::invertDisplay(uint8_t i) {
  if (i) {
    ssd1306_command(SSD1306_INVERTDISPLAY);
  } else {
    ssd1306_command(SSD1306_NORMALDISPLAY);
  }
}

void ESP_SSD1306::ssd1306_command(uint8_t c) {
  if (sid != -1)
  {
    // SPI
    digitalWrite(cs, HIGH);		//uncommented for ESP8266 compatibility
    //    *csport |= cspinmask;		//commented for ESP8266 compatibility
    digitalWrite(dc, LOW);		//uncommented for ESP8266 compatibility
    //    *dcport &= ~dcpinmask;	//commented for ESP8266 compatibility
    digitalWrite(cs, LOW);		//uncommented for ESP8266 compatibility
    //    *csport &= ~cspinmask;	//commented for ESP8266 compatibility
    fastSPIwrite(c);
    digitalWrite(cs, HIGH);		//uncommented for ESP8266 compatibility
    //    *csport |= cspinmask;		//commented for ESP8266 compatibility
  }
  else
  {
    // I2C
    uint8_t control = 0x00;   // Co = 0, D/C = 0
    Wire.beginTransmission(_i2caddr);
    WIRE_WRITE(control);
    WIRE_WRITE(c);
    Wire.endTransmission();
    yield();
  }
}

// startscrollright
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ESP_SSD1306::startscrollright(uint8_t start, uint8_t stop) {
  ssd1306_command(SSD1306_RIGHT_HORIZONTAL_SCROLL);
  ssd1306_command(0X00);
  ssd1306_command(start);
  ssd1306_command(0X00);
  ssd1306_command(stop);
  ssd1306_command(0X00);
  ssd1306_command(0XFF);
  ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

// startscrollleft
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ESP_SSD1306::startscrollleft(uint8_t start, uint8_t stop) {
  ssd1306_command(SSD1306_LEFT_HORIZONTAL_SCROLL);
  ssd1306_command(0X00);
  ssd1306_command(start);
  ssd1306_command(0X00);
  ssd1306_command(stop);
  ssd1306_command(0X00);
  ssd1306_command(0XFF);
  ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

// startscrolldiagright
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ESP_SSD1306::startscrolldiagright(uint8_t start, uint8_t stop) {
  ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA);
  ssd1306_command(0X00);
  ssd1306_command(SSD1306_LCDHEIGHT);
  ssd1306_command(SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL);
  ssd1306_command(0X00);
  ssd1306_command(start);
  ssd1306_command(0X00);
  ssd1306_command(stop);
  ssd1306_command(0X01);
  ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

// startscrolldiagleft
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void ESP_SSD1306::startscrolldiagleft(uint8_t start, uint8_t stop) {
  ssd1306_command(SSD1306_SET_VERTICAL_SCROLL_AREA);
  ssd1306_command(0X00);
  ssd1306_command(SSD1306_LCDHEIGHT);
  ssd1306_command(SSD1306_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL);
  ssd1306_command(0X00);
  ssd1306_command(start);
  ssd1306_command(0X00);
  ssd1306_command(stop);
  ssd1306_command(0X01);
  ssd1306_command(SSD1306_ACTIVATE_SCROLL);
}

void ESP_SSD1306::stopscroll(void) {
  ssd1306_command(SSD1306_DEACTIVATE_SCROLL);
}

// Dim the display
// dim = true: display is dimmed
// dim = false: display is normal
void ESP_SSD1306::dim(boolean dim) {
  uint8_t contrast;

  if (dim) {
    contrast = 0; // Dimmed display
  } else {
    if (_vccstate == SSD1306_EXTERNALVCC) {
      contrast = 0x9F;
    } else {
      contrast = 0xCF;
    }
  }
  // the range of contrast to too small to be really useful
  // it is useful to dim the display
  ssd1306_command(SSD1306_SETCONTRAST);
  ssd1306_command(contrast);
}

void ESP_SSD1306::ssd1306_data(uint8_t c) {
  if (sid != -1)
  {
    // SPI
    digitalWrite(cs, HIGH);		//uncommented for ESP8266 compatibility
    //*csport |= cspinmask;		//commented for ESP8266 compatibility
    digitalWrite(dc, HIGH);		//uncommented for ESP8266 compatibility
    //*dcport |= dcpinmask;		//commented for ESP8266 compatibility
    digitalWrite(cs, LOW);		//uncommented for ESP8266 compatibility
    //*csport &= ~cspinmask;	//commented for ESP8266 compatibility
    fastSPIwrite(c);
    digitalWrite(cs, HIGH);		//uncommented for ESP8266 compatibility
    //*csport |= cspinmask;		//commented for ESP8266 compatibility
  }
  else
  {
    // I2C
    uint8_t control = 0x40;   // Co = 0, D/C = 1
    Wire.beginTransmission(_i2caddr);
    WIRE_WRITE(control);
    WIRE_WRITE(c);
    Wire.endTransmission();
  }
}

void ESP_SSD1306::display(void) {
  ssd1306_command(SSD1306_COLUMNADDR);
  ssd1306_command(0);   // Column start address (0 = reset)
  ssd1306_command(SSD1306_LCDWIDTH - 1); // Column end address (127 = reset)

  ssd1306_command(SSD1306_PAGEADDR);
  ssd1306_command(0); // Page start address (0 = reset)
#if SSD1306_LCDHEIGHT == 64
  ssd1306_command(7); // Page end address
#endif
#if SSD1306_LCDHEIGHT == 32
  ssd1306_command(3); // Page end address
#endif
#if SSD1306_LCDHEIGHT == 16
  ssd1306_command(1); // Page end address
#endif

  if (sid != -1)
  {
    // SPI
    digitalWrite(cs, HIGH);		//added for ESP8266 compatibility
    //	*csport |= cspinmask;		//commented for ESP8266 compatibility
    digitalWrite(dc, HIGH);		//added for ESP8266 compatibility
    //	*dcport |= dcpinmask;		//commented for ESP8266 compatibility
    digitalWrite(cs, LOW);		//added for ESP8266 compatibility
    //	*csport &= ~cspinmask;		//commented for ESP8266 compatibility

    for (uint16_t i = 0; i < (SSD1306_LCDWIDTH * SSD1306_LCDHEIGHT / 8); i++) {
      fastSPIwrite(buffer[i]);
      //ssd1306_data(buffer[i]);
    }
    digitalWrite(cs, HIGH);		//added for ESP8266 compatibility
    //	*csport |= cspinmask;		//commented for ESP8266 compatibility
  }
  else
  {
    // save I2C bitrate
#ifndef __SAM3X8E__
    //    uint8_t twbrbackup = TWBR;			//commented for ESP8266 compatibility
    //    TWBR = 12; // upgrade to 400KHz!		//commented for ESP8266 compatibility
#endif

    //Serial.println(TWBR, DEC);
    //Serial.println(TWSR & 0x3, DEC);

    // I2C
    for (uint16_t i = 0; i < (SSD1306_LCDWIDTH * SSD1306_LCDHEIGHT / 8); i++) {
      // send a bunch of data in one xmission
      Wire.beginTransmission(_i2caddr);
      WIRE_WRITE(0x40);
      for (uint8_t x = 0; x < 16; x++) {
        WIRE_WRITE(buffer[i]);
        i++;
      }
      i--;
      Wire.endTransmission();
      yield();
    }
#ifndef __SAM3X8E__
    //    TWBR = twbrbackup;					//commented for ESP8266 compatibility
#endif
  }
}

// clear everything
void ESP_SSD1306::clearDisplay(void) {
  memset(buffer, 0, (SSD1306_LCDWIDTH * SSD1306_LCDHEIGHT / 8));
}


inline void ESP_SSD1306::fastSPIwrite(uint8_t d) {

  if (hwSPI) {
    //   (void)SPI.transfer(d);
  } else {
    for (uint8_t bit = 0x80; bit; bit >>= 1) {
      *clkport &= ~clkpinmask;
      if (d & bit) *mosiport |=  mosipinmask;
      else        *mosiport &= ~mosipinmask;
      *clkport |=  clkpinmask;
    }
  }
  //*csport |= cspinmask;
}

void ESP_SSD1306::drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
  boolean bSwap = false;
  switch (rotation) {
    case 0:
      // 0 degree rotation, do nothing
      break;
    case 1:
      // 90 degree rotation, swap x & y for rotation, then invert x
      bSwap = true;
      adagfxswap(x, y);
      x = WIDTH - x - 1;
      break;
    case 2:
      // 180 degree rotation, invert x and y - then shift y around for height.
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
      x -= (w - 1);
      break;
    case 3:
      // 270 degree rotation, swap x & y for rotation, then invert y  and adjust y for w (not to become h)
      bSwap = true;
      adagfxswap(x, y);
      y = HEIGHT - y - 1;
      y -= (w - 1);
      break;
  }

  if (bSwap) {
    drawFastVLineInternal(x, y, w, color);
  } else {
    drawFastHLineInternal(x, y, w, color);
  }
}

void ESP_SSD1306::drawFastHLineInternal(int16_t x, int16_t y, int16_t w, uint16_t color) {
  // Do bounds/limit checks
  if (y < 0 || y >= HEIGHT) {
    return;
  }

  // make sure we don't try to draw below 0
  if (x < 0) {
    w += x;
    x = 0;
  }

  // make sure we don't go off the edge of the display
  if ( (x + w) > WIDTH) {
    w = (WIDTH - x);
  }

  // if our width is now negative, punt
  if (w <= 0) {
    return;
  }

  // set up the pointer for  movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y / 8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;

  register uint8_t mask = 1 << (y & 7);

  switch (color)
  {
    case WHITE:         while (w--) {
        *pBuf++ |= mask;
      }; break;
    case BLACK: mask = ~mask;   while (w--) {
        *pBuf++ &= mask;
      }; break;
    case INVERSE:         while (w--) {
        *pBuf++ ^= mask;
      }; break;
  }
}

void ESP_SSD1306::drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
  bool bSwap = false;
  switch (rotation) {
    case 0:
      break;
    case 1:
      // 90 degree rotation, swap x & y for rotation, then invert x and adjust x for h (to become w)
      bSwap = true;
      adagfxswap(x, y);
      x = WIDTH - x - 1;
      x -= (h - 1);
      break;
    case 2:
      // 180 degree rotation, invert x and y - then shift y around for height.
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
      y -= (h - 1);
      break;
    case 3:
      // 270 degree rotation, swap x & y for rotation, then invert y
      bSwap = true;
      adagfxswap(x, y);
      y = HEIGHT - y - 1;
      break;
  }

  if (bSwap) {
    drawFastHLineInternal(x, y, h, color);
  } else {
    drawFastVLineInternal(x, y, h, color);
  }
}


void ESP_SSD1306::drawFastVLineInternal(int16_t x, int16_t __y, int16_t __h, uint16_t color) {

  // do nothing if we're off the left or right side of the screen
  if (x < 0 || x >= WIDTH) {
    return;
  }

  // make sure we don't try to draw below 0
  if (__y < 0) {
    // __y is negative, this will subtract enough from __h to account for __y being 0
    __h += __y;
    __y = 0;

  }

  // make sure we don't go past the height of the display
  if ( (__y + __h) > HEIGHT) {
    __h = (HEIGHT - __y);
  }

  // if our height is now negative, punt
  if (__h <= 0) {
    return;
  }

  // this display doesn't need ints for coordinates, use local byte registers for faster juggling
  register uint8_t y = __y;
  register uint8_t h = __h;


  // set up the pointer for fast movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y / 8) * SSD1306_LCDWIDTH);
  // and offset x columns in
  pBuf += x;

  // do the first partial byte, if necessary - this requires some masking
  register uint8_t mod = (y & 7);
  if (mod) {
    // mask off the high n bits we want to set
    mod = 8 - mod;

    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    // register uint8_t mask = ~(0xFF >> (mod));
    static uint8_t premask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };
    register uint8_t mask = premask[mod];

    // adjust the mask if we're not going to reach the end of this byte
    if ( h < mod) {
      mask &= (0XFF >> (mod - h));
    }

    switch (color)
    {
      case WHITE:   *pBuf |=  mask;  break;
      case BLACK:   *pBuf &= ~mask;  break;
      case INVERSE: *pBuf ^=  mask;  break;
    }

    // fast exit if we're done here!
    if (h < mod) {
      return;
    }

    h -= mod;

    pBuf += SSD1306_LCDWIDTH;
  }


  // write solid bytes while we can - effectively doing 8 rows at a time
  if (h >= 8) {
    if (color == INVERSE)  {          // separate copy of the code so we don't impact performance of the black/white write version with an extra comparison per loop
      do  {
        *pBuf = ~(*pBuf);

        // adjust the buffer forward 8 rows worth of data
        pBuf += SSD1306_LCDWIDTH;

        // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
        h -= 8;
      } while (h >= 8);
    }
    else {
      // store a local value to work with
      register uint8_t val = (color == WHITE) ? 255 : 0;

      do  {
        // write our value in
        *pBuf = val;

        // adjust the buffer forward 8 rows worth of data
        pBuf += SSD1306_LCDWIDTH;

        // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
        h -= 8;
      } while (h >= 8);
    }
  }

  // now do the final partial byte, if necessary
  if (h) {
    mod = h & 7;
    // this time we want to mask the low bits of the byte, vs the high bits we did above
    // register uint8_t mask = (1 << mod) - 1;
    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    static uint8_t postmask[8] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F };
    register uint8_t mask = postmask[mod];
    switch (color)
    {
      case WHITE:   *pBuf |=  mask;  break;
      case BLACK:   *pBuf &= ~mask;  break;
      case INVERSE: *pBuf ^=  mask;  break;
    }
  }
}
